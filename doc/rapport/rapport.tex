\documentclass[final,a4paper,10pt]{article}
\usepackage[utf8]{inputenc}
\usepackage[danish]{babel}
\usepackage{natbib}
\bibliographystyle{dk-plainnat}



\usepackage{url}
\usepackage[final]{graphicx}
\usepackage{verbatim}
\usepackage{amsmath}
\usepackage{lscape}
\usepackage{multicol}
\usepackage[draft]{fixme}
\usepackage{tikz}
\usepackage{pgflibrarytikztrees}
\usepackage{lastpage}
\usepackage{listings}
\usepackage{fancyvrb}

\usepackage{wrapfig}                           %Mulighed for at wrappe tekst om figurer
\usepackage{fancyhdr}                          %Flere muligheder med headere og footere
\usepackage{lastpage}                          %Mulighed for at referere til sidste sidetal




\headheight 14.5pt                             %H<F8>jden af headeren
\textwidth 5.87in                              %Tekstbredden

\pagestyle{fancy}                              %Benyt fancyhdr-pakken
\fancyhead[R]{\thepage\ af \pageref{LastPage}} %Skriv sidetallene som "x af y"
\fancyhead[L]{N-dronning problemet i MiG}              %Headeren
\fancyfoot[C]{}                                %Fjern sidetallet som er standard

\oddsidemargin 0.2in                           %Venstre margin er 1in + dette tal
                                               %Med en textwidth p<E5> 5.87in og en
                                               %oddsidemargin p<E5> 0.2 bliver marginerne
                                               %lige store p<E5> A4 som er 8,27in bredt
\font\chessfont=skak10
\def\chs#1{{\chessfont#1}}
\newcommand{\mig}{MiG}
\newcommand{\oc}{One-Click}


\title{Bachelorprojekt\\N-dronning problemet i MiG}
\author{Thomas Clement Mogensen \\ Frej Soya \\ Alex Esmann }

\begin{document}

\maketitle
\tableofcontents

\newpage
\setcounter{page}{1}
\abstract
\begin{verse}
	En del af indholdet af problemformulereringen fra synopsen flyttes til henholdsvis resumé, \ref{nqueenproblemet} og \ref{migogoneclick}. Selve synopsen inkluderes som bilag. Resuméet skal være ren gentagelse.
\end{verse}
\fixme{slet?}
Projektets formål er ikke at beregne en løsning til N-dronning-problemet for $n=26$, hvilket problemets beregningsmæssige omfang kombineret med tids- og ressourcebegræsninger udelukker i praksis. Men kun at muliggøre og forhåbentlig igangsætte denne beregning.
Vi vil ikke tage stilling til den benyttede algoritmes korrekthed eller effektivitet, men kun til den bedst mulige strategi for parallelisering. Partitionering af problemdata skal foregå på en fornuftig måde, med tanke på hvordan det forventes beregningsressourcerne opfører sig, men en decideret statisk undersøgelse af midlertidige MiG-ressourcers opførsel eller levetid vil ikke blive foretaget\footnote{Med ressourcers opførsel tænkes på den tid man kan forvente en bruger vil lade sin one-click-klient køre}. Fordele og ulemper ved MiG eller One-click i forhold til andre grid-systemer falder også udenfor opgavens omfang.

Ved at at løse problemet for et lavere $n$ vil vi kunne estimere tiden og/eller antal CPU'er der skal bruges for at løse for n=26.

 Opgaven behandler følgende delproblemer:
\begin{itemize}
\item At finde en effektiv strategi til parallelisering af Takakens algoritme. Herunder overvejelser omkring den optimale størrelse på delproblemer.
\item Implementation af algoritmen i java på en sådan måde at den kan afvikles af one-click-klienter.
\item Strategi for indsamling, behandling og præsentation af delresultater.
\item Første opgave er naturligvis at få et bedre kendskab til MiG.
\end{itemize}


\subsection*{Konklusion}\label{konklusion}
\begin{verse}
	Kortfattet konklusion på løsningen og processen
\end{verse}

\section{Nqueen-problemet}\label{nqueenproblemet}

NQueen problemet er finde antallet af måder man kan placere N dronninger på et et kvadratisk NxN bræt, således at ingen dronning kan slå en anden. Bemærk at vi skal finde alle løsninger $Q(n)$, og ikke bare finde alle løsninger - hvilket er et helt andet problem. Hidtil er der kun fundet løsninger for $n \in \{1,...,25\}$.\cite{sekvenser}. Derudover beskriver \cite{etsi} en manuelt distribueret løsning for $n=25$. Der findes desuden masser af referencer på \url{http://www.liacs.nl/home/kosters/nqueens.html} relateret til nqueen problemet. 


\begin{figure}
\begin{center}
\begin{tabular}{|c|c|c|c|c|c}
\hline	 &  & &   \chs{q} & \\
\hline	\chs{q} & &  &  & \\
\hline	 & & \chs{q} &  &  \\
\hline	 &  &  & & \chs{q} \\
\hline	 & \chs{q} & &  &  \\
\hline
\end{tabular}
\end{center}
\caption{Eksempel på en løsning for $n=5$}
\end{figure}


\subsection{Backtracking}\label{backtracking}

En 

\fixme{Træstruktur kunne være endnu bedre med et grid i hver knude der viser valgte pladser med en markering}

\begin{tikzpicture}[node distance=1cm]
	%    \tikzstyle{every node}=[draw]    
	\node (root) {} child {edge from parent};
\end{tikzpicture}


\begin{figure}[!h]

\begin{tikzpicture}[node distance=1cm]
	%    \tikzstyle{every node}=[draw]
    \node (root) {} [grow=right]
   	    child 
   	    child 
	    child
    	child {node (2) {2}
	        child  {node (25) {5}
    	  		child {node  {3}
    	  			child { node{1} child { node{4}} }
	      		}
    	   		child {node {1} child {node{4}}}        		        	          		        	  
	       	}
		    child {node {4}
		    	child {node {1}
		    		child {node {3} child { node {5}} }
		    	} 
		    }
	     }
	     child 
	 ;

\end{tikzpicture}
\caption{Ovenstående løsning hvor vi allerede har valgt 2 i række 1, kan den følgende udregning vises som et træ.
Antallet af børn er antallet af \textit{mulige} valg som ikke blokeres af tidligere placeringer}
	
\end{figure}


\subsection{Bitmapmodellen}\label{bitmapmodellen}
\begin{verse}
	Beskrivelse af NQueen problemet som bitmaps / bit vektorer
\end{verse}

Samme bræt repræsenteres som et binært mønster. \textbf{1} markerer placering af en dronning. Det totale antal løsninger er begrænset af $n!$. 
Et bræt med en eller flere valgte linjer kan løses på samme måde med takakens algoritme. Hvert delbræt kan løses uafhængigt og antallet af løsninger for hvert bræt akkumuleres for at få det totale antal løsninger.

Dette kan gentages for hver linje. Ved at oprette delbræt hvor M linjer allerede er valgt. Findes ca. (N-M)! delbræt skal der for N=26 vil der for M=3 være 26*25*24=15,600 delbræt.

Dette er en øvre grænse, der oprettes ikke delbræt som ikke er gyldige, og derudover er der i takakens kode optimeringer så der kun findes unikke løsninger (som så kan roteres og eller spejles)


\subsection{Takakens backtrack optimeringer}\label{backtrackoptimeringer}
\begin{verse}
	Vi har afgrænset os fra at beskrive Takakens optimeringer, endsige vise deres korrekthed. I dette afsnit vil vi dog alligevel diskutere optimeringernes overordnede virkemåde. Dog kun i det omfang det er nødvendigt for at kunne omstrukturere algoritmen uden at miste optimeringer.   
\end{verse}

Takaken opdeler beregningen i to delproblemer. Et hvor den første dronning placeres i øverste hjørne, og et andet delproblem hvor dronningen placeres i midten. For løsninger med dronninger i hjørnet fjernes løsninger i kolonne 2 fra fra$2 \ldots n-2$. 


\subsection{Sikkerhed}

\section{\mig\ og \oc}\label{migogoneclick}
\begin{verse}
	Her beskrives \mig-grid og \oc\ overordnet. Tekniske detaljer i forbindelse med brug af \mig-grid, og særligt udvikling af one-click-applikationer, identificeres. Dette afsnit henvender sig således kun til dig, der ikke allerede har kendskab til disse emner.  
\end{verse}

\subsection{Minimum intrusion Grid}\label{mig}

Minimum instrusion Grid, herefter \mig, er et grid-system der sigter efter at stille så få krav for deltagelse som muligt - både overfor brugere og ressourcer. I \mig-termiologi er en ressource en enhed der kan sættes til at beregne et problem. I mange andre gridsystemer benyttes speciel software til kommunikation mellem den enkelte ressource og gridet, undgår man helt dette mindskes kompleksiteten af det samlede system dramatisk. Omkostninger til den første opsætning og efterfølgende vedligeholdelse af systemet minimeres. \fixme{beskrivelse af anonymitet, sikkerhed, skalerbarhed}. \mig er beskrevet indgåede i \cite{simplemig,mig}.

\mig\ giver brugeren mulighed for at få adgang til et stort antal beregningsressourcer, uden at skulle bekymre sig om hvor disse befinder sig, hvem der ejer dem, hvorvidt de hver især er istand til at løse den aktuelle opgave\footnote{Et givent problem kan f.eks. stille særlige krav til ressourcens arkitektur, eksisterende programmel, osv. }\fixme{footnote er der mere under osv?}. Her og i det nedenstående henviser udtrykket ""brugeren"" til en udvikler der ønsker at få beregnet et problem vha. \mig \fixme{mindre fjollet definition}. Brugeren præsenteres for en abstraktion af \mig, der fremstiller et kendt paradigme fra unix-systemer; et hjemmekatalog hvori brugeren kan placere sine data- og programfiler. Brugerens interaktion med \mig\ forgår via en række scripts der efterligner kendte kommandoer til manipulation af filer i hjemmekataloget, og introducerer kommandoer til at starte og stoppe job. Begge metoder giver mulighed for at udføre basale funktioner på \mig, såsom at igangsætte job, se status på tidligere jobs og give adgang til data-, program- og resultatfiler i hjemmekataloget. Et job sættes igang ved at køre kommandoen migsubmit med såkaldt mRSL-fil\footnote{\mig\ Resource Selector Language} der indeholder en beskrivelse af det job der skal afvikles. Beskrivelsen fortæller \mig\ hvilken programfil der skal køres, med hvilke parametre, hvor lang tid jobbet forventes at tage og eventuelle krav jobbet har til ressourcer der skal afvikle det. Et kørende job har adgang filerne i  hjemmekataloget. Resultatet af et job skal skrives til hjemmekataloget for senere at kunne aflæses af brugeren. For hvert job oprettes desuden 3 filer i hjemmekataloget. De indeholder hhv. exit-status, standard output og standard error, ganske som de kendes fra unix-systemer. 
Al den ovennævnte interaktion med \mig\ kan alternativt foregå gennem et særligt webinterface. 
Vores system har flere dele, selve Grid delen er \mig\ som for os er en lukket boks
Da en delopgave specifikt er at bruge og afprøve OneClick som kører som en java Applet.

TODO: Andre system ting?

\subsection{\oc}\label{applet}
\fixme{flyt til oneclick}
\oc muliggør deltagelse i et MiG-grid uden andre forudsætninger end en webbrowser og java. Tilgengæld er denne metode begrænset til at afvikle programmer, der er tilgængelige som java-bytecode. Brug af one-click giver adgang til et enormt (potentielt) antal beregningsressourcer, hvilket er grunden til at benytte one-click i denne opgave.
OneClick er et framework til udvikling af java-appletter, der kan interagere med \mig\. Ved hjælp af OneClick kan en hvilken som helst computer gøres til en \mig-ressource, unden nogen for for opsætning eller installation af programmel, hvilket gør det muligt for ganske alm. mennesker at bidrage regnekraft til gridet. Det eneste der kræves er en webbrowser der kan afvikle java-appletter. Implementerer man sit job som en java-applet vil det kunne afvikles på alle OneClick-ressourcer, uden at skulle specificere særlige krav til arkitektur med videre. Til gengæld vil det være begrænset til kun at køre på OneClick-ressourcer. 
OneClick er især interessant i forbindelse med hvad man kunne kalde sociale beregninger, det vil sige beregningsprojekter som almindelige mennesker kunne have interesse i at bidrage til, eller endog konkurrere om at bidrage mest til. Kendte eksempler på sådanne projekter er SETI@home og FOLDING@home. Når måling af tidsforbrug per resource bliver implementeret i OneClick kunne man også  forestille sig et \mig-grid som en åben markedsplads hvor både virksomheder og privatpersoner kunne købe og sælge regnekraft gennem \mig\ uden at skulle bekymre sig om, eller have mulighed for at vide, hvor beregningerne reelt foretages eller hvad hvad der regnes på. \fixme{for meget blah-blah}


En java-applet afvikles i et lukket miljø, en såkaldt sandkasse, for at beskytte den maskine der afvikler appletten. n række begrænsinger vi bliver nødt til at forholde os til
\begin{itemize}
	\item Appletten kan maksimalt allokere 64MB hukommelse.
	\item Java's jni (Java Native Interfaces) kan ikke benyttes fra appletter. 
	\item Ingen adgang til at læse/skrive lokale filer.
	\item Appletten er begrænset til kun at kunne oprette netværksforbindelser til den ip-adresse den er hentet fra.
	\item Ingen mulighed for at starte programmer på klient-maskinen.
	\item OneClick Kode/Mininum intrusion.
\end{itemize}

Af disse er kun de to første af betydning for vores formål. Det bliver naturligvis et krav at alle delproblemer vi sender ud kan beregnes uden at bruge mere end 64MB hukommelse på klienten. Uden jni har vi ikke mulighed for måle på hvor meget reel cputid vores applet har fået tildelt, eller kende resourcens hastighed eller arkitektur. 

En java-applet afvikles i et lukket miljø, 


\section{Paralellisering af Takaken's nqueen I Java}

\subsection{Generelle implementeringsovervejelser}
\subsubsection{Opdeling af opgaver}

\begin{itemize}
\item{Vi er nødt til at tage højde for at løsningen (antallet af løsinger) vil overstige hvad vi kan repræsentere som en 32bit værdi. }
\end{itemize}

\subsubsection{Joboprettelse}
Et NQueen-job består af en .mRSL-fil og en  
\fixme{hvordan opretter vi job, hvad består et job af(serialze, mrsl)}

\subsubsection{Skemalægning af job}
I \mig skemalægges afviklingen af job som en FIFO-kø. Dvs. at job afvikles i samme rækkefølge som de submittes til gridet. Ved udløb af tidsfristen for afvikling af jobbet placeres jobbet bagerst i køen. I forbindelse med 

\subsubsection{Resultatindsamling}
I forbindelse med joboprettelse og resultatindsamling skal vi træffe nogle valg mht. 
\begin{itemize}
\item{Joboprettelsesstrategi - hvad skal der til for at beskrive et job.}
\item{}
\end{itemize}

\subsection{One-click-specifikke begrænsninger}

I forbindelse med udvikling og afprøvning af en \oc-applet skal man være opmærksom på at Class-filer caches af browserens java-plugin. Ændringer i implementeringen kan medføre fejl under afviklingen på resourcer der bruger forældede class-filer, selvom \mig opfatter jobbet som udført uden fejl. Ændringer i class-filer, der betyder opdatering af serialVersionUID, kræver opdatering af denne cache. Man kan altså riskikere at appletten får en undtagelse på serialVersionUID og derved markeres jobbet som færdigt, uden at være kommet til et resultat. En uhensigtsmæssighed i forbindelse med undtagelseshåndtering i basisklassen MigJob.java gør at jobbet alligevel vil se ud til at være afsluttet succesfuldt. Se afsnit \cite{bugs}. 


\subsubsection{Bugs og mangler}\label{bugs}
\begin{itemize}
	\item Et job fejler ikke hvis jobbet kaster en java.lang.Error (Forskellig fra Java.lang.Exception, begge har dog typen java.lang.Throwable)
	\item Ens job tvinges til at afhænge af MiG.nqueen.JoB
	\item File I/O følger ikke Inputstream / Outputstream	
	\item Brug af suns egen HTTP implementation. Brug i stedet http-commons fra Apache
	\item Vi har glemt en masse 
	\item Webstart vil klart være at foretrække. Det er rigtigt at der kommer en certifikat fejl (https) - men så længe certifikat ikke er i browserens CA liste vil browseren i stedet komme med en advarsel.
\end{itemize}


\subsection{Konkrete implementeringsproblemer}
\subsubsection{Mig job}\label{label}
\subsubsection{Iterative udgave}
\subsection{Checkpoint}

Fordi checkpointing gemmer ikke stack.


\subsection{Resultatindsamling og -visning}
Vi skal have en vedligeholdelsesproces kørende, der sørger for at 

- Frej Lad \mig sende en mail pr. færdigt job? Og så et job der checker 'jævnligt' at alle mails er modtaget?


\subsection{Resultatindsamling og -visning}
En måde et holde styr på den samlede beregning af en løsning på n-dronning-problemet er, at have en vedligeholdelsesproces kørende, der sørger for at 
\begin{itemize}
	\item Genkøre fejlede job
	\item Indsamle resultater fra færdige jobs
	\item Muliggøre løbende projektstatus og offentliggørelse af resultater 
\end{itemize}
Dette program kan for eksempel være det samme der står for at oprette vores jobs i første omgang. Muligheden for at tilpasse ikke-kørte jobs på baggrund af informationer om gridets tilstand (antallet af tilgængelige resourcer). 

Som alternativ tilbyder \mig-grid at informere indsendere når dennes job er afsluttet, eksempelvis via email. Det vil være betydeligt enklere kun at foretage behandling af resultater hver gang et sådant er klar, uden at have et permanent indsamlingsprogram kører. Vi er dog stadig nødsaget til at håndtere fejl i det enkelte job eller rapporteringen af jobafslutning. 



\section{Implementeringens struktur}\label{implementeringensstruktur}
\begin{verse}
	Følgende er ment som en læsevejledning til programmets kildekode, såvel som en vejledning til afvikling af programmet med forskellige formål. 
\end{verse}

Den udviklede kildekode er organiseret i følgende filer:
\begin{itemize}
	\item[Board.java] 
	\item[Board2.java] Basis-klasse for wrapper-klasser til backtrack
	\item[CornerBoard.java] wrapper-klasse til backtrack for cornerboards
	\item[MiddleBoard.java] wrapper-klasse til backtrack for middleboard
	\item[CheckPointer.java] implementerer checkpointing
	\item[CheckPointAction.java] implementerer checkpointing
	\item[CornerBoardTest.java] unittests til CornerBoard
	\item[MiddelBoardTest.java] unittests til MiddleBoard
	\item[MiGClient.java] java-implementation af en del af \mig-grid-hjælpeprogrammerne
	\item[MiGJob.java] klasse der beskriver et job og kan generere en .mRSL-fil
	\item[MiGSSLSocketFactory.java] hjælpeklasse til MiGClient-klassen
	\item[NQueenBoards.java] Jobgeneratoren, parallel-nqueen-algoritme, der genererer delproblemer i form af boards, hvor de første $m$ dronninger allerede er placeret. 
	\item[NQueenJob.java] hovedklassen for et \mig-grid-\oc-job. 
	\item[NQueens.java] Testfil - Direkte java-port af Takakens c-kode. Kan køres som one-click job.
	\item[NQueensL.java] Testfil - Direkte java-port af Takakens c-kode. Kan køres lokalt.
\end{itemize}

Programmet kan afvikles lokalt på en enkelt maskine eller på \mig-grid,  



\section{Afprøvning og benchmarking}
%Benchmarking-delens fremmeste formål er at finde svar på en række spørgsmål inden udregningen sættes igang.
%Reelt har vi kun en enkelt parameter vi kan skrue på, nemlig $m$ - antallet af dronninger vi placerer på hver board før vi genererer et mig job til at regne videre på det board. 
%Hvilket forhold mellem 

%\subsection{Takaken}
%\subsection{Java port}
%\subsection{Java port v2}
%\subsubsection{Rekursion vs. Iterativ metode}
%\subsubsection{Iterativ med checkpoints}
%\subsection{MiGrid}

\input{benchmark.tex}
TODO
\section{Forbedringer til OneClick / MiGrid}
%\input{forbedringer.tex}
\fixme{TODO}
langsom til at sende resultatet til serveren hvis browseren dør mens den er ved
at sende resultatet til serveren, er det ikke sikkert den når at smide hele

oneclick applet'en cacher class filer, s hvis man har ænret i sin kode og
uploadet nye class filer bliver man nødt til at lukke browseren helt ned og
starte den op igen, hvis man vil have den til at loade de nye class filer, lader
det umiddelbart til.. 

oneclick applet'en kommer hele tiden med en popup fejl, hvis brugeren ikke har
certificat (skal nok lige verificeres, var noget jeg fik at vide af Asser, da
han legede resource for mig)

Job Status side ala. Files/Folders
tingen, så man nemmere kan vælge flere jobs og cancelle/resubmitte.. og
wildcards til migcancel.py ville også være en go ting, så man kunne lave en
migcancel.py *14\_37* fx.. 

vis queued/cancelled/finished/executing/m.fl jobs ville også være en brugbar feature

mulighed for at slette job helt, så ens jobstatus side ikke er så stor.. eller
"pensionere" dem

Den dræber nogen gange jobs, dette ser ud til at ske, hvis den lige har
færdiggjort job <jobid>, og så (af en eller anden årsag) prøver at hente det
\_samme\_ job igen, så bliver dette job (sjovt nok) slået ihjel af serveren, og
så sleeper applet'en i 80s før den prøver igen.. 

Errors bliver ikke fanget
\begin{verbatim}
checkpoint_request_url_str: https://mig-1.imada.sdu.dk/sid_redirect/7bc01a0e4ead439c63c84fd149eb93ac325fdf1809aedc23049c010890bf14bd/13768_6_2_2007__8_42_57_mig-1.imada.sdu.dk.0.NQueenJob.checkpoint.latest
Exception in thread "Thread-18" java.lang.NoClassDefFoundError: CheckPointAction
	at java.lang.Class.getDeclaredMethods0(Native Method)
	at java.lang.Class.privateGetDeclaredMethods(Class.java:2427)
	at java.lang.Class.getMethod0(Class.java:2670)
	at java.lang.Class.getMethod(Class.java:1603)
	at MiG.oneclick.Exe.getJobMethods(Exe.java:73)
	at MiG.oneclick.Exe.run(Exe.java:236)
	at java.lang.Thread.run(Thread.java:619)
sendJobFinished
\end{verbatim}

%\bibliographystyle{plainnat}


\bibliography{rapport}

\appendix
%\landscape
%\tiny


\section{Kildekode}
\subsection{nqueens.c}
%\verbatiminput{../../nqueens.c}

\section{Synopsis}
%\input{synopsis.tex}


\input{benchmark-output.tex}
%\begin{multicols}{2}[\section{\LaTeX kildekode}]
%\section*{Skabelon.tex}
%\verbatiminput{skabelon.tex}
%\end{multicols}


\end{document}
