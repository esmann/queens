\documentclass[a4,10pt]{article}

\usepackage[danish]{babel}
\usepackage[utf8]{inputenc}
\usepackage{verbatim}
\usepackage{amsmath}
\usepackage{lscape}
\usepackage{multicol}


\font\chessfont=skak10
\def\chs#1{{\chessfont#1}}
\def\OC{OneClick}
\title{Bachelorprojekt\\N-dronning problemet i MiG}
\author{Thomas Clement Mogensen \\ Frej Soya \\ Alex Esmann }

%\maketitle

\begin{document}
\maketitle
\tableofcontents

\tableofcontents

\abstract{}

\section{Problemformulering}\label{problemformulering}
\begin{verse}
	En del af indholdet af problemformulereringen fra synopsen flyttes til henholdsvis resumé, \ref{nqueenproblemet} og \ref{migogoneclick}. Selve synopsen inkluderes som bilag. Resuméet skal være ren gentagelse.
\end{verse}
%\input{problemformulering.tex}
at implementere en parallel udgave af Takakens algoritme til løsning af n-dronning-problemet. Algoritmen skal køre på MiG-systemet (Minimum Intrusion Grid) og MiG's one-click arkitektur skal kunne udnyttes til at skaffe ressourcer til beregning af problemet. Formålet er på langt sigt at få beregnet en løsning til N-dronning-problemet for $n=26$, men opgaven er kun at gøre dette muligt ved hjælp af MiG. N-dronning-problemet er et klassisk beregningsproblem, der går ud på at finde antallet af mulige måder n dronninger kan placeres på et "skakbræt" med n x n felter, uden at nogen af dem er istand til at slå hinanden i næste træk. Problemets størrelse stiger eksponentielt med n, og er uhyre beregningstungt for store n, hvorfor store distribuerede systemer ofte benyttes. Hidtil er der kun fundet løsninger for $n \in \{1,...,25\}$. For distlab-gruppen her på diku ville en løsning for $n=26$, beregnet på et MiG-grid, kunne skabe opmærksomhed omkring MiG-systemet.

MiG er beskrevet indgående i \cite{simplemig} og \cite{mig}, \cite{etsi} beskriver N-dronning-problemet grundigere end ovenstående og præsenterer en løsning for n=25. Appendix queens.c i \cite{etsi} er en udskrift af Takakens algoritme implementeret i C.

One-click muliggør deltagelse i et MiG-grid uden andre forudsætninger end en webbrowser og java. Tilgengæld er denne metode begrænset til at afvikle programmer, der er tilgængelige som java-bytecode. Brug af one-click giver adgang til et enormt (potentielt) antal beregningsressourcer, hvilket er grunden til at benytte one-click i denne opgave.

Opgaven indeholder altså følgende delproblemer:
\begin{itemize}
\item At finde en effektiv strategi til parallelisering af Takakens algoritme. Herunder overvejelser omkring den optimale størrelse på delproblemer.
\item Implementation af algoritmen i java på en sådan måde at den kan afvikles af one-click-klienter.
\item Strategi for indsamling, behandling og præsentation af delresultater.
\item Første opgave er naturligvis at få et bedre kendskab til MiG.
\end{itemize}

\subsection{Afgrænsninger}\label{afgraensninger}
%\input{afgraæensninger.tex}

Projektets formål er ikke at beregne en løsning til N-dronning-problemet for $n=26$, hvilket problemets beregningsmæssige omfang kombineret med tids- og ressourcebegræsninger udelukker i praksis. Men kun at muliggøre og forhåbentlig igangsætte denne beregning.
Vi vil ikke tage stilling til den benyttede algoritmes korrekthed eller effektivitet, men kun til den bedst mulige strategi for parallelisering. Partitionering af problemdata skal foregå på en fornuftig måde, med tanke på hvordan det forventes beregningsressourcerne opfører sig, men en decideret statisk undersøgelse af midlertidige MiG-ressourcers opførsel eller levetid vil ikke blive foretaget\footnote{Med ressourcers opførsel tænkes på den tid man kan forvente en bruger vil lade sin one-click-klient køre}. Fordele og ulemper ved MiG eller One-click i forhold til andre grid-systemer falder også udenfor opgavens omfang.

Ved at at løse problemet for et lavere $n$ vil vi kunne estimere tiden og/eller antal CPU'er der skal bruges for at løse for n=26.



\section{Konklusion}\label{konklusion}
\begin{verse}
	Kortfattet konklusion på løsningen (og processen?).
\end{verse}



\section{Nqueen-problemet}\label{nqueenproblemet}
\begin{verse}
	Her beskriver vi selve nqueen-problemet, og Takakens optimerede backtrack algoritme.
\end{verse}

Placering af N dronninger på et skabbræt med $NxN$ størrelse
Eksempel på en løsning for $n=5$
FIXME
%\begin{tabular}{|c|c|c|c|c|l}
%       4 & 3 & 2 & 1 &  0 & \\
%\hline &  &  &  & \chs{q} & 0 \\
%\hline \chs{q} &  &  &  &  		  & 1 \\
%\hline &  &  & \chs{q} &  & 2\\
%\hline &  &  &  &  		  & 3 \\
%\hline & Q &  &  &  		  & 4\\
%\hline
%\end{tabular}

\subsection{Bitmapmodellen}\label{bitmapmodellen}

Samme bræt repræsenteret som et binært mønster. \textbf{1} markerer  placering af en dronning





På den første linje kan en dronning placeres 5 forskellige steder



QXXXX
XQXXX
XXQXX
XXXQX
XXXXQ


Et bræt med en eller flere valgte linjer kan løses på samme måde med takakens algoritme.

Hvert delbræt kan løses uafhængigt og antallet af løsninger kan akkumuleres for at få det totale antal løsninger.


Dette kan gentages for hver linje. Ved at oprette delbræt hvor M linjer allerede er valgt. Findes ca. (N-M)! delbræt skal der for N=26 vil der for M=3 være 26*25*24=15,600 delbræt.

Dette er en øvre grænse, der oprettes ikke delbræt som ikke er gyldige, og derudover er der i takakens kode optimeringer så der kun findes unikke løsninger (som så kan roteres og eller spejles)


Vi er sikre på at >10000 delproblemer er rigeligt, et grid har alligevel max 500-1000 ??? CPU'er?

Det tager lineær tid at oprette delboards, så vi bør uden problemer kunne skabe nok delboards. (Hukommelse er begrænsningen?)



\subsection{Takakens backtrack optimeringer}\label{backtrackoptimeringer}
\begin{verse}
	Vi har afgrænset os fra at beskrive Takakens optimeringer, endsige vise deres korrekthed. I dette afsnit vil vi dog alligevel diskutere optimeringernes overordnede virkemåde. Dog kun i det omfang det er nødvendigt for at kunne omstrukturere algoritmen uden at miste optimeringer.   
\end{verse}





\section{MiG og one-click}\label{migogoneclick}
\begin{verse}
	Her beskrives MiG-grid og one-click overordnet. Tekniske detaljer i forbindelse med brug af MiG-grid, og særligt udvikling af one-click-applikationer, identificeres. Dette afsnit henvender sig således kun til dig, der ikke allerede har kendskab til disse emner.  
\end{verse}

Vores system har flere dele, selve Grid delen er MiG som for os er en lukket boks
Da en delopgave specifikt er at bruge og afprøve OneClick som kører som en java Applet.

Minimum Intrusion Grid
TODO: Andre system ting?
\subsection{MiG}\label{mig}




\subsection{OneClick Applet}\label{applet}
Begrænsinger pga, applets
\begin{itemize}
	\item Sandbox model
	\item max 64 mb ram
	\item OneClick Kode/Mininum intrusion
\end{itemize}

\section{Paralellisering af Takaken's nqueen I Java}

\subsection{Generelle implementeringsovervejelser}
\subsubsection{Opdeling af opgaver}

\begin{itemize}
\item{Vi er nødt til at tage højde for at løsningen (antallet af løsinger) vil overstige hvad vi kan repræsentere som en 32bit værdi. }
\end{itemize}

I forbindelse med joboprettelse og resultatindsamling skal vi træffe nogle valg mht.
\begin{itemize}
\item{Joboprettelsesstrategi - hvad skal der til for at beskrive et job.}
\item{}
\end{itemize}

\subsection{One-click-specifikke begrænsninger}

Class-filer caches af browserens java-plugin. Ændringer i class-filer, der betyder opdatering af serialVersionUID, kræver at browseren genstartes for ikke at fejle på serialVersionUID og derved færdiggøre jobbet, men uden resultat! 

\subsubsection{Bugs og mangler}
\begin{itemize}
	\item Et job fejler ikke hvis jobbet kaster en java.lang.Error (Forskellig fra Java.lang.Exception, begge har dog typen java.lang.Throwable)
\end{itemize}


\subsection{Konkrete implementeringsproblemer}
\subsubsection{Mig job}\label{label}
\subsubsection{Iterative udgave}
\subsection{Checkpoint}

Fordi checkpointing gemmer ikke stack.


\subsection{Resultatindsamling og -visning}
Vi skal have en vedligeholdelsesproces kørende, der sørger for at 

- Frej Lad mig sende en mail pr. færdigt job? Og så et job der checker 'jævnligt' at alle mails er modtaget?


\subsection{Resultatindsamling og -visning}
En måde et holde styr på den samlede beregning af en løsning på n-dronning-problemet er, at have en vedligeholdelsesproces kørende, der sørger for at 
\begin{itemize}
	\item Genkøre fejlede job
	\item Indsamle resultater fra færdige jobs
	\item Muliggøre løbende projektstatus og offentliggørelse af resultater 
\end{itemize}
Dette program kan for eksempel være det samme der står for at oprette vores jobs i første omgang. Muligheden for at tilpasse ikke-kørte jobs på baggrund af informationer om gridets tilstand (antallet af tilgængelige resourcer). 

Som alternativ tilbyder migrid at informere indsendere når dennes job er afsluttet, eksempelvis via email. Det vil være betydeligt enklere kun at foretage behandling af resultater hver gang et sådant er klar, uden at have et permanent indsamlingsprogram kører. Vi er dog stadig nødsaget til at håndtere fejl i det enkelte job eller rapporteringen af jobafslutning. 



\section{Implementeringens struktur}\label{implementeringensstruktur}
\begin{verse}
	Følgende er ment som en læsevejledning til programmets kildekode, såvel som en vejledning til afvikling af programmet til forskellige formål. 
\end{verse}

Den udviklede kildekode er organiseret i følgende filer:
\begin{itemize}
	\item[Board.java] 
	\item[Board2.java] Basis-klasse for wrapper-klasser til backtrack
	\item[CornerBoard.java] wrapper-klasse til backtrack for cornerboards
	\item[MiddleBoard.java] wrapper-klasse til backtrack for middleboard
	\item[CheckPointer.java] implementerer checkpointing
	\item[CheckPointAction.java] implementerer checkpointing
	\item[CornerBoardTest.java] unittests til CornerBoard
	\item[MiddelBoardTest.java] unittests til MiddleBoard
	\item[MiGClient.java] java-implementation af en del af migrid-hjælpeprogrammerne
	\item[MiGJob.java] klasse der beskriver et job og kan generere en .mRSL-fil
	\item[MiGSSLSocketFactory.java] hjælpeklasse til MiGClient-klassen
	\item[NQueenBoards.java] Jobgeneratoren, parallel-nqueen-algoritme, der genererer delproblemer i form af boards, hvor de første $m$ dronninger allerede er placeret. 
	\item[NQueenJob.java] hovedklassen for et migrid-one-click-job. 
	\item[NQueens.java] Testfil - Direkte java-port af Takakens c-kode. Kan køres som one-click job.
	\item[NQueensL.java] Testfil - Direkte java-port af Takakens c-kode. Kan køres lokalt.
\end{itemize}

Programmet kan afvikles lokalt på en enkelt maskine eller på migrid,  



\section{Afprøvning og benchmarking}
Benchmarking-delens fremmeste formål er at finde svar på en række spørgsmål inden udregningen sættes igang.
Reelt har vi kun en enkelt parameter vi kan skrue på, nemlig $m$ - antallet af dronninger vi placerer på hver board før vi genererer et mig job til at regne videre på det board. 
Hvilket forhold mellem 

\subsection{Takaken}
\subsection{Java port}
\subsection{Java port v2}
\subsubsection{Rekursion vs. Iterativ metode}
\subsubsection{Iterativ med checkpoints}
\subsection{MiGrid}

%\input{benchmark.tex}
TODO
\section{Forbedringer til OneClick}
%\input{forbedringer.tex}
TODO


\begin{thebibliography}{99}
\bibitem{simplemig} Karlsen, Henrik Hoey, Vinter, Brian:
\emph{Minimum intrusion Grid - The simple model},
http://mig-1.imada.sdu.dk/MiG/Mig/published\_papers/ETN05-Simple.pdf (2005)
\bibitem{mig} Vinter, Brian:
\emph{The Architecture of the Minimum intrusion Grid, MiG},
http://mig-1.imada.sdu.dk/MiG/Mig/published\_papers/CPA05-Arch.pdf
(2005)
\bibitem{etsi} Guillemin, Patrick:
\emph{3rd N Queens ETSI Plugtests Contest - Counting the number of
  solutions Single and Distributed Programs}
http://portal.etsi.org/docbox/GRID/Open/GRID\%20Plugtests\%202006/N-QUEENS-TESTCASE-2006-v2.pdf (2006)
\end{thebibliography}



\appendix
%\landscape
%\tiny

\section{Kildekode}
\subsection{nqueens.c}
%\verbatiminput{../../nqueens.c}



%\begin{multicols}{2}[\section{\LaTeX kildekode}]
%\section*{Skabelon.tex}
%\verbatiminput{skabelon.tex}
%\end{multicols}

\end{document}
